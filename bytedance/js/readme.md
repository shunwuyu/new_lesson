- instance 如何使用
  'hello tuture' instanceof String
- let 会产生临时性死区
  以下代码的报错是：
  console.log(a);
  let a = 1;
  错误是： connot access a before initialization

  - 词法环境
  - 变量提升
  - 三个过程
    变量的创建，初始化，赋值是三个不同的过程
    var  自己的创建和初始化阶段
    即在词法环境对象填充变量时即将变量初始化为undefined
    let声明的变量仅仅是提升了自己的创建阶段，并没有提升自己的初始化阶段
    变量的初始化阶段是在执行上下文的执行阶段而非创建阶段
  - JS编译的词法分析过程
    词法环境对象的规范对象
    声明的变量(var let )，函数(提升的本质)，参数(arguments)全都填充为自己的属性



  在当前的执行上下文中，会进行变量提升，
  但是未被初始化， 
  所以在执行上下文执行阶段，执行代码如果还没有执行到变量赋值，就引用此变量就会报错，此变量未初始化。

- 变量提升提升的是哪些东西？
  函数运行的过程有哪些？
    - 先创建执行上下文，
    - 执行上下文入栈
    - 处于栈顶时，开始运行执行上下文。
  
  创建执行上下文的过程中会做三件事
    - 变量对象
      首先会为 arguments 创建一个属性，值为 arguments，
       function 函数声明，创建一个同名属性，值为函数的引用，
       接着会扫码 var 变量声明，创建一个同名属性，值为 undefined，这就是变量提升。
        let    没值
    - 创建作用域链
    - this 

- 如何判断数组类型 3.js
  Array.isArray([]) 

- 函数中的arguments是数组 5.js吗？类数组转数组的方法了解一下？
  是类数组，是属于鸭子类型6.js 7.js的范畴，长得像数组，

- setTimeout(fn, 0)
  setTimeout 按照顺序放到队列里面，然后等待函数调用栈清空之后才开始执行，而这些操作进入队列的顺序，则由设定的延迟时间来决定

  相差的时间是越来越大的，越来越不准确。 8.js

  ，假如定时器里面的代码需要进行大量的计算(耗费时间较长)，或者是 DOM 操作。这样一来，花的时间就比较长，有可能前一次代码还没有执行完，后一次代码就被添加到队列了。也会到时定时器变得不准确，甚至出现同一时间执行两次的情况。

- JS 隐式转换，显示转换
  一般非基础类型进行转换时会先调用 valueOf，如果 valueOf 无法返回基本类型值，就会调用 toString


https://juejin.cn/post/6949527975595360269

